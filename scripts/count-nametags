#!/usr/bin/env python

import argparse
from eulxml.xmlmap import load_xmlobject_from_file
from eulxml.xmlmap.eadmap import EncodedArchivalDescription as EAD, \
    EAD_NAMESPACE
from eulxml.xmlmap.teimap import Tei, TEI_NAMESPACE
import sys

from namedropper import util


class CountNameTags(object):
    'Count tagged personal, corporate, and geographic names in an XML document'

    def __init__(self):
        # parse command-line arguments and init spotlight client
        parser = argparse.ArgumentParser(
            description=self.__doc__)
        # FIXME: take a list of filenames? does multiple filenames make sense?
        parser.add_argument('filename', metavar='INPUT_FILE', type=str,
            help='name of the file to be processed')

        self.args = parser.parse_args()

        # auto-detect input type if not specified
        self.input_type = util.autodetect_file_type(self.args.filename)
        # exit if we still don't have an input type
        if not self.input_type:
            print >> sys.stderr, 'Could not determine document input type'
            exit(-1)
        elif self.input_type == 'tei':
            print >> sys.stderr, 'TEI is not yet supported'
            exit(-1)

        xmlobj = self.init_xml_object()
        # common xpath arguments to declare ead namespace
        xp_args = {'namespaces': {'e': EAD_NAMESPACE, 't': TEI_NAMESPACE}}

        # shortcut method for running an xpath query
        def xp(xpath):
            return xmlobj.node.xpath(xpath, **xp_args)

        info = {}
        # total counts
        info['personal'] = xp('count(.//e:persname)')
        info['corporate'] = xp('count(.//e:corpname)')
        info['geographic'] = xp('count(.//e:geogname)')

        summary = '%(personal)d personal names \n' + \
                '%(corporate)d corporate names \n' + \
                '%(geographic)d geographic names \n'
        print summary % info

        # totals with authority source & number

        # get a unique list of authority source names (e.g., viaf)
        # - using set because lxml xpath doesn't support distinct-values
        name_sources = set(xp('.//e:persname[@authfilenumber]/@source|' + \
            './/e:corpname[@authfilenumber]/@source|' + \
            './/e:geogname[@authfilenumber]/@source'))

        types = {
            'persname': 'personal',
            'corpname': 'corporate',
            'geogname': 'geographic'
        }

        if name_sources:
            print 'Names with authority control:'

            # total count of names by authority source
            for src in name_sources:
                # filter each name type by source attribute
                sf = '[@source = "%s"]' % src
                count = xp('count(.//e:persname%s|' % sf + \
                    './/e:corpname%s|.//e:geogname%s)' % (sf, sf))
                print '  %s: %d' % (src, count)

                # total unique identifiers for this source per name type
                for name_type, name_label in types.iteritems():
                    unique_ids = set(xp('.//e:%s%s/@authfilenumber' \
                        % (name_type, sf)))
                    if unique_ids:
                        print '    %d unique %s identifiers' % \
                            (len(unique_ids), name_label)

    # FIXME: copied from lookup-names; move to common utils (script baseclass?)
    def init_xml_object(self):
        # initialize an xmlobject based on user-specified arguments
        # for filename and type

        # NOTE: this part is slightly different from lookup-names
        if self.input_type == 'ead':
            xmlobj_class = EAD
        elif self.input_type == 'tei':
            xmlobj_class = Tei

        try:
            return load_xmlobject_from_file(self.args.filename, xmlobj_class)
        except Exception as err:
            print 'Error loading %s as XML: %s' % (self.args.filename, err)
            exit(-1)


if __name__ == '__main__':
    CountNameTags()
